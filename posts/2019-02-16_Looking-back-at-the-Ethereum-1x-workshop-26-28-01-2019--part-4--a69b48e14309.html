<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Looking back at the Ethereum 1x workshop 26–28.01.2019 (part 4)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Looking back at the Ethereum 1x workshop 26–28.01.2019 (part 4)</h1>
</header>
<section data-field="subtitle" class="p-summary">
This is continuation of the part 1 and part2 and part3
</section>
<section data-field="body" class="e-content">
<section name="668b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7489" id="7489" class="graf graf--h3 graf--leading graf--title">Looking back at the Ethereum 1x workshop 26–28.01.2019 (part 4)</h3><p name="b426" id="b426" class="graf graf--p graf-after--h3">This is continuation of the <a href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-1-70c1ebd93266" data-href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-1-70c1ebd93266" class="markup--anchor markup--p-anchor" target="_blank">part 1</a> and <a href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-2-d3d8fdcede10" data-href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-2-d3d8fdcede10" class="markup--anchor markup--p-anchor" target="_blank">part2</a> and <a href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-3-cc162ca04e9f" data-href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-3-cc162ca04e9f" class="markup--anchor markup--p-anchor" target="_blank">part3</a></p><h3 name="ec65" id="ec65" class="graf graf--h3 graf-after--p">Problems with large (and growing) state</h3><h4 name="8a93" id="8a93" class="graf graf--h4 graf-after--h3">Failing snapshot sync</h4><p name="fe30" id="fe30" class="graf graf--p graf-after--h4">Described in part 1</p><h4 name="abe7" id="abe7" class="graf graf--h4 graf-after--p">Duration of snapshot sync</h4><p name="8c6c" id="8c6c" class="graf graf--p graf-after--h4">Described in part 1</p><h4 name="144e" id="144e" class="graf graf--h4 graf-after--p">Slower block sealing</h4><p name="0eb4" id="0eb4" class="graf graf--p graf-after--h4">Described in part 2</p><h4 name="56b4" id="56b4" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Slower processing of transactions reading from the state</strong></h4><p name="2c4f" id="2c4f" class="graf graf--p graf-after--h4">Described in part 3</p><p name="8394" id="8394" class="graf graf--p graf-after--p">I mentioned data analysis on speculative execution of transactions in parallel. This will also be somewhat relevant to the next section about the Block gas limit.</p><p name="e370" id="e370" class="graf graf--p graf-after--p">What follows is the model of speculative concurrent execution I used for my analysis (there could be other models, but this should give you a rough idea of what kind of “concurrency” you can get without fancy things like static analysis, symbolic pre-execution etc.). A block of transactions is executed in two phases:</p><ol class="postList"><li name="133f" id="133f" class="graf graf--li graf-after--p">Concurrent speculative phase (cache warming)</li><li name="ebcc" id="ebcc" class="graf graf--li graf-after--li">Sequential precise phase (use of warmed caches)</li></ol><p name="7a93" id="7a93" class="graf graf--p graf-after--li">In the concurrent speculative phase, all transactions of the block are executed concurrently against the state that existed at the beginning of the block. Their writes are isolated from each other. If all the state reads are synchronised on a barrier and performed as a batch, the number of database accesses may reduce to the maximum number of reads in one transaction. For example, if we had a block with five transactions:</p><figure name="abbc" id="abbc" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 78px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 11.1%;"></div><img class="graf-image" data-image-id="1*ShHKq1I832lOwjoo5qH4yA.png" data-width="1983" data-height="220" src="https://cdn-images-1.medium.com/max/800/1*ShHKq1I832lOwjoo5qH4yA.png"></div><figcaption class="imageCaption">Block with five transactions that contain varied number of reads (maximum 4)</figcaption></figure><p name="bdb9" id="bdb9" class="graf graf--p graf-after--figure">Then, execution in the concurrent speculative phase may look like this:</p><figure name="694d" id="694d" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 592px; max-height: 816px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 137.79999999999998%;"></div><img class="graf-image" data-image-id="1*0VKkOxnSgPtBSwycssEcrA.png" data-width="592" data-height="816" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*0VKkOxnSgPtBSwycssEcrA.png"></div><figcaption class="imageCaption">State reads are grouped in 4 database accesses</figcaption></figure><p name="eb90" id="eb90" class="graf graf--p graf-after--figure">In this example, although there 8 state reads in 5 transactions in total, if we run them concurrently, state reads could be grouped into 4 accesses to the database, because 4 is the maximum number of reads any transaction does in this block. Let’s call this “maximum” reads.</p><p name="2f57" id="2f57" class="graf graf--p graf-after--p">Of course, there is no guarantee that the execution of transactions in such a way would yield the same results as the sequential execution. But if most of the reads are performed from the “static” locations, then there would be a big overlap in the sets of locations accessed by the correct, sequential execution, and locations accessed by such concurrent speculative execution.</p><p name="2451" id="2451" class="graf graf--p graf-after--p">In the sequential precise phase, transactions are executed how they are supposed to be executed, one after another, but using the cache that was built up during the concurrent speculative execution. In our example, this could look like this:</p><figure name="4434" id="4434" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 229px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 32.7%;"></div><img class="graf-image" data-image-id="1*R6N9tZHhuCmF_u-EW0-epg.png" data-width="1920" data-height="627" src="https://cdn-images-1.medium.com/max/800/1*R6N9tZHhuCmF_u-EW0-epg.png"></div><figcaption class="imageCaption">All state reads except 2, can be served from the cache built in the concurrent speculative phase</figcaption></figure><p name="d189" id="d189" class="graf graf--p graf-after--figure">In this example, most reads in this sequential phase can proceed without access to the state database, because the locations they are accessing were already accessed by the concurrent speculative phase. Only 2 locations are new, because, for example, transaction #4 uses the value obtained by the first read to calculate the locations for the next 2 reads. Let’s call these “extra” reads.</p><p name="a4fb" id="a4fb" class="graf graf--p graf-after--p">So how much overlap in read locations would we get if used this 2-phase execution model?</p><p name="43c7" id="43c7" class="graf graf--p graf-after--p">First two charts show the analysis for the account reads. Black line shows number of “naked” account reads per block. Red line shows number of “extra” reads, and blue line shows the sum of “maximum” reads and “extra” reads:</p><figure name="f560" id="f560" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 394px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="1*i-z9L4FUcqTQY0xZDhN8tw.png" data-width="1280" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*i-z9L4FUcqTQY0xZDhN8tw.png"></div></figure><p name="ee16" id="ee16" class="graf graf--p graf-after--figure">This chart is not every helpful, because it is overwhelmed by the “tower” of spam attacks of 2016. If we only show blocks &gt; 4m, we can see better:</p><figure name="1d21" id="1d21" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 394px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="1*TNdvEbQC7A3NXZ4oFuvaiw.png" data-width="1280" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*TNdvEbQC7A3NXZ4oFuvaiw.png"></div></figure><p name="27f3" id="27f3" class="graf graf--p graf-after--figure">If we do the same analysis for the SLOADs, we get this. Here, blue line is total “naked” SLOADs (this is how many DB accesses we would get if we did not use 2-phase strategy), yellow line is the sum of “maximum” SLOADs, and “extra” SLOADs, and the red line is “extra” SLOADs.</p><figure name="c1a9" id="c1a9" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 394px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="1*zRLEcFYiY8Q1p_nrvNl0mg.png" data-width="1280" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*zRLEcFYiY8Q1p_nrvNl0mg.png"></div></figure><p name="9193" id="9193" class="graf graf--p graf-after--figure">It can be easily seen that SLOAD opcode presents a bigger performance burden than reading accounts:</p><ol class="postList"><li name="e75f" id="e75f" class="graf graf--li graf-after--p">Number of maximum SLOADs per block is around 100 on average, whereas the number of account reads per block is around 20 on average</li><li name="f3dc" id="f3dc" class="graf graf--li graf-after--li">Sometimes there are clusters of SLOADs with context-dependent locations (this is where the blue line is “punctured” by the red tower).</li><li name="fcaf" id="fcaf" class="graf graf--li graf-after--li">The “win” of using concurrent speculative strategy for SLOAD is about 3x or 4x on average, whereas it is 8x or 9x on average for account reads.</li></ol><h3 name="d1bf" id="d1bf" class="graf graf--h3 graf-after--li">Block gas limit increase and the State fees (formerly known as State rent) share initial steps</h3><p name="b330" id="b330" class="graf graf--p graf-after--h3">During the workshop, we were discussing the State Rent proposal <a href="https://github.com/ledgerwatch/eth_state/blob/master/State_Rent_2.pdf" data-href="https://github.com/ledgerwatch/eth_state/blob/master/State_Rent_2.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">version 2</a>. Now that the latest State Fees proposal (<a href="https://github.com/ledgerwatch/eth_state/blob/master/State_Fees_3.pdf" data-href="https://github.com/ledgerwatch/eth_state/blob/master/State_Fees_3.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">version 3</a>) is published, I can use it for concreteness.</p><p name="09ee" id="09ee" class="graf graf--p graf-after--p">The main concern about raising the block gas limit further now is that it would likely accelerate the state size growth, because there will potentially be more state expansion operations (non-zero value transaction or CALL to a “fresh” address, CREATE, CREATE2, SSTORE) in a block, and every block happens every 15 seconds on average. Therefore, it seems logical, that some sort of “speed bumps” needs to be applied to these operations before the block gas limit can be safely increased. In the State Fees proposals these speed bumps are changes H and J, which are rent prepayments that are mandated for all such operations:</p><figure name="aebb" id="aebb" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 386px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 55.2%;"></div><img class="graf-image" data-image-id="1*ZjVYRF6GOZcfvT_dmdjn8A.png" data-width="2054" data-height="1134" src="https://cdn-images-1.medium.com/max/800/1*ZjVYRF6GOZcfvT_dmdjn8A.png"></div><figcaption class="imageCaption">Rent prepayment changes H and J are highlighted by brown ovals</figcaption></figure><p name="c0a4" id="c0a4" class="graf graf--p graf-after--figure">Prepayments for contract storage operation SSTORE are a delicate matter, and some balancing is required. On one hand, we only want to charge prepayments if SSTORE expands the storage (changes value from 0 to non-0). On the other hand, we want to make storage hoarding useless by also charging prepayments even if SSTORE does not expand the storage, but changes the storage that existed previously. That is why change J requires knowing the correct number of storage items in every contract, and that is why it is in the fork 2, not fork 1.</p><p name="cda5" id="cda5" class="graf graf--p graf-after--p">At the workshop, we had an idea of so-called “client side” accounting, which would seem to eliminate the need for 2 hard-forks to introduce contract sizes into the Ethereum state. However, thinking about this more, I realised that the coordination required for such “client side” accounting is probably going to be more than the coordination required for a hard fork.</p><p name="c130" id="c130" class="graf graf--p graf-after--p">Having written the part 3 of this blog post, I have also realised that the increase of block gas limit has another potential performance effect. It would likely increase the number of account reads and SLOAD opcodes that are executed within one transaction and within one block. Therefore, I wonder, if the gas costs of the state read operations will have to go up as well?</p><h3 name="7114" id="7114" class="graf graf--h3 graf-after--p">Stateless contract pattern is discouraged by the current gas schedule</h3><p name="ee51" id="ee51" class="graf graf--p graf-after--h3">To appear in the part 5 or later</p><h3 name="e094" id="e094" class="graf graf--h3 graf-after--p">eWASM interpreters could be a sensible first change even though gas cost might not be practical in the beginning</h3><p name="508c" id="508c" class="graf graf--p graf-after--h3">To appear in the part 5 or later</p><h3 name="4404" id="4404" class="graf graf--h3 graf-after--p">Chain pruning will become more relevant as we start constraining the state growth</h3><p name="3cc6" id="3cc6" class="graf graf--p graf-after--h3">To appear in the part 5 or later</p><h3 name="da8a" id="da8a" class="graf graf--h3 graf-after--p">Ethereum protocol changes do not need to take a year to be prepared</h3><p name="f15d" id="f15d" class="graf graf--p graf-after--h3 graf--trailing">To appear in the part 5 or later</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@akhounov" class="p-author h-card">Alexey Akhunov</a> on <a href="https://medium.com/p/a69b48e14309"><time class="dt-published" datetime="2019-02-16T20:49:31.542Z">February 16, 2019</time></a>.</p><p><a href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-4-a69b48e14309" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 28, 2020.</p></footer></article></body></html>