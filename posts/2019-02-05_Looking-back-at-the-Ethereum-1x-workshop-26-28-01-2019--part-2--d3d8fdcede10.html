<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>
      Looking back at the Ethereum 1x workshop 26–28.01.2019 (part 2)
    </title>
    <style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html,
      body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field="subtitle"],
      section[data-field="description"] {
        display: none;
      }
    </style>
  </head>
  <body>
    <article class="h-entry">
      <header>
        <h1 class="p-name">
          Looking back at the Ethereum 1x workshop 26–28.01.2019 (part 2)
        </h1>
      </header>
      <section data-field="subtitle" class="p-summary">
        This is continuation of the part 1
      </section>
      <section data-field="body" class="e-content">
        <section
          name="b080"
          class="section section--body section--first section--last"
        >
          <div class="section-divider"><hr class="section-divider" /></div>
          <div class="section-content">
            <div class="section-inner sectionLayout--insetColumn">
              <h3
                name="91c4"
                id="91c4"
                class="graf graf--h3 graf--leading graf--title"
              >
                Looking back at the Ethereum 1x workshop 26–28.01.2019 (part 2)
              </h3>
              <p name="7345" id="7345" class="graf graf--p graf-after--h3">
                This is continuation of the
                <a
                  href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-1-70c1ebd93266"
                  data-href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-1-70c1ebd93266"
                  class="markup--anchor markup--p-anchor"
                  target="_blank"
                  >part 1</a
                >
              </p>
              <h3 name="f422" id="f422" class="graf graf--h3 graf-after--p">
                Problems with large (and growing) state
              </h3>
              <h4 name="8a93" id="8a93" class="graf graf--h4 graf-after--h3">
                Failing snapshot sync
              </h4>
              <p name="fe30" id="fe30" class="graf graf--p graf-after--h4">
                Described in part 1
              </p>
              <h4 name="6cbf" id="6cbf" class="graf graf--h4 graf-after--p">
                Duration of snapshot sync
              </h4>
              <p name="eb86" id="eb86" class="graf graf--p graf-after--h4">
                Described in part 1
              </p>
              <h4 name="144e" id="144e" class="graf graf--h4 graf-after--p">
                Slower block sealing
              </h4>
              <p name="0eb4" id="0eb4" class="graf graf--p graf-after--h4">
                For the purpose of this post, I have refreshed the data about
                the occupancy of the account trie (and now the storage tries)
                with the very recent block, 7&#39;173&#39;251. I am glad to say
                that the process of calculating this with Turbo-Geth database is
                now quite efficient: 4 minutes for accounts trie and 18 minutes
                for storage tries.
              </p>
              <figure
                name="a5be"
                id="a5be"
                class="graf graf--figure graf-after--p"
              >
                <div
                  class="aspectRatioPlaceholder is-locked"
                  style="max-width: 700px; max-height: 348px;"
                >
                  <div
                    class="aspectRatioPlaceholder-fill"
                    style="padding-bottom: 49.7%;"
                  ></div>
                  <img
                    class="graf-image"
                    data-image-id="1*9ZYDO7Bchs4JB8IM5O6QJg.png"
                    data-width="2047"
                    data-height="1018"
                    data-is-featured="true"
                    src="https://cdn-images-1.medium.com/max/800/1*9ZYDO7Bchs4JB8IM5O6QJg.png"
                  />
                </div>
                <figcaption class="imageCaption">
                  Number of accounts: 52&#39;799&#39;322, number of trie nodes:
                  72&#39;601&#39;839
                </figcaption>
              </figure>
              <figure
                name="f625"
                id="f625"
                class="graf graf--figure graf-after--figure"
              >
                <div
                  class="aspectRatioPlaceholder is-locked"
                  style="max-width: 700px; max-height: 242px;"
                >
                  <div
                    class="aspectRatioPlaceholder-fill"
                    style="padding-bottom: 34.599999999999994%;"
                  ></div>
                  <img
                    class="graf-image"
                    data-image-id="1*TSvna_Hk0fw6cvRXEM4teg.png"
                    data-width="2330"
                    data-height="806"
                    src="https://cdn-images-1.medium.com/max/800/1*TSvna_Hk0fw6cvRXEM4teg.png"
                  />
                </div>
                <figcaption class="imageCaption">
                  Number of storage items: 165&#39;287&#39;953, number of trie
                  nodes: 222&#39;821&#39;353
                </figcaption>
              </figure>
              <p name="cefe" id="cefe" class="graf graf--p graf-after--figure">
                The second table is aggregating together storage tries of all
                existing contracts, that it why it does not have such a
                predictable structure as the first one, which represent a single
                trie of accounts (both contracts and non-contracts).
              </p>
              <p name="07fc" id="07fc" class="graf graf--p graf-after--p">
                The average depth of a node in the account trie is 7.89. Given
                that the levels 0 to 4 (or even 0 to 5) of the trie can be
                permanently cached in memory, we can say that the average access
                depth is 3.89 or 2.89. The average depth of a node in the
                storage tries is 5.38. It can be impractical to permanently
                cache even the first level of the storage tries in memory, so we
                assume that caching will not have a big effect on the depth
                there.
              </p>
              <p name="7967" id="7967" class="graf graf--p graf-after--p">
                Now, if transactions in a block modify the state, then at the
                end of the block the new root hash of the state needs to be
                updated. Each modification requires recomputing the hash on
                every level of the trie. In turn, recomputing of the hash
                requires fetching the “sibling” hashes. On the picture below,
                the recalculated hashes are shown in green, and “sibling” hashes
                are shown in grey:
              </p>
              <figure
                name="ab11"
                id="ab11"
                class="graf graf--figure graf-after--p"
              >
                <div
                  class="aspectRatioPlaceholder is-locked"
                  style="max-width: 700px; max-height: 272px;"
                >
                  <div
                    class="aspectRatioPlaceholder-fill"
                    style="padding-bottom: 38.9%;"
                  ></div>
                  <img
                    class="graf-image"
                    data-image-id="1*bGATKFwvBGmzgbOKEhgTww.png"
                    data-width="2032"
                    data-height="791"
                    src="https://cdn-images-1.medium.com/max/800/1*bGATKFwvBGmzgbOKEhgTww.png"
                  />
                </div>
              </figure>
              <p name="f48e" id="f48e" class="graf graf--p graf-after--figure">
                It is clear that the deeper the modified entries are in the
                state trie, the more sibling hashes need to be fetched. Each row
                of 16 hashes is one so-called branch node, and it can be fetched
                with 1 random database read in most Ethereum clients. Therefore,
                we can say that number of database reads is currently on the
                order of 3 (2.89 rounded) or 4 (3.89 rounded) for one account
                modification, and 5 or 6 (5.38 rounded) for one storage item
                modification. These numbers will keep growing, but not linearly
                (rather logarithmically) with the size of the state. It is
                possible for a powerful adversary to push these some of these
                numbers for some type of transactions.
              </p>
              <p name="56b6" id="56b6" class="graf graf--p graf-after--p">
                Most SSTORE operations that are happening currently operate on
                the items that have already been accessed by another SSTORE or
                SLOAD within the same block, therefore no extra fetching is
                required in such cases. This could be explained by the way
                solidity compiler deals with types such as
                <strong class="markup--strong markup--p-strong">address </strong
                >or<strong class="markup--strong markup--p-strong"> bool</strong
                >, which do not take an entire 32-byte word. When solidity code
                updates values of such types, the compiler generates the code
                that tries to protect the existing bits that do not belong to
                the type. For example, this code:
              </p>
              <pre
                name="bade"
                id="bade"
                class="graf graf--pre graf-after--p"
              >pragma solidity ^0.5.0;<br>contract Bool {<br>    bool b;<br>    constructor() public {<br>        b = true;<br>    }<br>}</pre>
              <p name="4df0" id="4df0" class="graf graf--p graf-after--pre">
                generates this snippet for
                <code class="markup--code markup--p-code">b=true:</code>
              </p>
              <pre
                name="b4e0"
                id="b4e0"
                class="graf graf--pre graf-after--p"
              >/* &quot;Bool.sol&quot;:79:87  b = true */<br>dup1<br>sload<br>not(0xff)<br>and<br>/* &quot;Bool.sol&quot;:83:87  true */<br>0x1<br>/* &quot;Bool.sol&quot;:79:87  b = true */<br>or<br>swap1<br>sstore</pre>
              <p name="7850" id="7850" class="graf graf--p graf-after--pre">
                I am currently running an analysis that retraces all
                transactions and counts how many SSTOREs are “naked” (modifying
                items not previously accessed within the block) and the total
                number of SSTOREs.
              </p>
              <p name="7051" id="7051" class="graf graf--p graf-after--p">
                Even though most of SSTOREs access items that do not need extra
                fetching at the end of the block, this can change. For example,
                solidity compiler can learn to optimise that behaviour away.
              </p>
              <p name="a612" id="a612" class="graf graf--p graf-after--p">
                In conclusion, we can say that number of database reads
                necessary for the block sealing is proportional to N1*4 for
                account modifications (N1 is number of “naked” successful
                account modifications in the block), or N2*6 for storage item
                modifications (N2 is number of “naked” successful SSTORE
                operations in the block). Each database read likely takes time
                proportional to log(<strong
                  class="markup--strong markup--p-strong"
                  >Sdb</strong
                >), where
                <strong class="markup--strong markup--p-strong">Sdb</strong> is
                the size of the state database. In total, the complexity of
                block sealing due to the state size (and indirectly state size
                database) is
              </p>
              <pre
                name="0dba"
                id="0dba"
                class="graf graf--pre graf-after--p"
              >4*N1*log(Sdb) for account modifications<br>6*N2*log(Sdb) for storage item modifications</pre>
              <p name="866e" id="866e" class="graf graf--p graf-after--pre">
                <strong class="markup--strong markup--p-strong"
                  >What happens when block sealing is slow?</strong
                >
              </p>
              <ol class="postList">
                <li name="7f2e" id="7f2e" class="graf graf--li graf-after--p">
                  Block sealing needs to be performed both by the miner who
                  creates the block and the miner who wishes to mine on top of
                  that block. The longer it takes, the more advantage is given
                  to the creator of the block. It is kind of inadvertent selfish
                  mining (please correct me if I am using terminology too
                  liberally here).
                </li>
                <li name="b619" id="b619" class="graf graf--li graf-after--li">
                  If verification of blocks takes bigger and bigger fraction of
                  inter-block time (currently it is around 300 ms / 15 s = 2%),
                  Ethereum nodes will become less able to keep up with the tip
                  of the chain.
                </li>
                <li name="bea1" id="bea1" class="graf graf--li graf-after--li">
                  If it takes a long time to seal a block, more mining pools
                  will adopt the strategy of “mission blocks”, described
                  <a
                    href="https://decryptmedia.com/3619/ethereum-spy-miner-stops"
                    data-href="https://decryptmedia.com/3619/ethereum-spy-miner-stops"
                    class="markup--anchor markup--li-anchor"
                    rel="noopener"
                    target="_blank"
                    >here</a
                  >, look for “F2Pool explains its empty blocks”. In short, when
                  miner received a new block from outside, they will quickly
                  construct an empty block (aka “mission block”) and start
                  mining it, while at the same time trying to construct a full
                  block. If they find correct nonce before the full block is
                  constructed, they just go ahead and publish empty block. If
                  not, they switch to mining the full block. As the sealing time
                  grows, it makes less and less sense NOT to use this strategy.
                </li>
              </ol>
              <p name="0492" id="0492" class="graf graf--p graf-after--li">
                <strong class="markup--strong markup--p-strong"
                  >Further investigations:</strong
                >
              </p>
              <ol class="postList">
                <li name="d8fa" id="d8fa" class="graf graf--li graf-after--p">
                  Collect and publish data on “naked” SSTOREs.
                </li>
                <li name="ef4b" id="ef4b" class="graf graf--li graf-after--li">
                  Measure the disparity of block sealing time in mining mode and
                  verification mode
                </li>
                <li name="a282" id="a282" class="graf graf--li graf-after--li">
                  Rerun the benchmarks used for calculate the gas cost of SLOAD
                  and SSTORE and see how much underpriced they are, possible
                  improve the benchmark
                </li>
                <li name="34b8" id="34b8" class="graf graf--li graf-after--li">
                  Analyse potential for concurrent execution of transactions to
                  amortise the latency of state access.
                </li>
              </ol>
              <p name="6fc2" id="6fc2" class="graf graf--p graf-after--li">
                <strong class="markup--strong markup--p-strong"
                  >Possible mitigations:</strong
                >
              </p>
              <ol class="postList">
                <li name="8350" id="8350" class="graf graf--li graf-after--p">
                  Optimise block sealing for miners, if disparity of block
                  sealing in mining mode and verification mode is significant
                </li>
                <li name="2a1c" id="2a1c" class="graf graf--li graf-after--li">
                  Separate current state from historical state in the state
                  database, to reduce the log(<strong
                    class="markup--strong markup--li-strong"
                    >Sdb</strong
                  >), this is already done in Turbo-Geth
                </li>
                <li name="122c" id="122c" class="graf graf--li graf-after--li">
                  Pre-warm the trie cache based on the transaction pool data
                </li>
                <li name="c648" id="c648" class="graf graf--li graf-after--li">
                  Raise the gas cost of SLOAD (this will not lead to hoarding as
                  the raising cost of SSTORE would)
                </li>
              </ol>
              <p name="ef7b" id="ef7b" class="graf graf--p graf-after--li">
                <strong class="markup--strong markup--p-strong"
                  >Solutions:</strong
                >
              </p>
              <p name="05d6" id="05d6" class="graf graf--p graf-after--p">
                Reduction of the state size, or at least the rate of its growth,
                should help limiting the problem, and allow the client software
                optimisations (such as advanced sync mechanisms) to catch up.
              </p>
              <h4 name="dac7" id="dac7" class="graf graf--h4 graf-after--p">
                Slower processing of transactions reading from the state
              </h4>
              <p name="6995" id="6995" class="graf graf--p graf-after--h4">
                To appear in the part 3 or later
              </p>
              <h3 name="d1bf" id="d1bf" class="graf graf--h3 graf-after--p">
                Block gas limit increase and the State fees (formerly known as
                State rent) share initial steps
              </h3>
              <p name="b330" id="b330" class="graf graf--p graf-after--h3">
                To appear in the part 3 or later
              </p>
              <h3 name="4448" id="4448" class="graf graf--h3 graf-after--p">
                Stateless contract pattern is discouraged by the current
                gas schedule
              </h3>
              <p name="ee51" id="ee51" class="graf graf--p graf-after--h3">
                To appear in the part 3 or later
              </p>
              <h3 name="e094" id="e094" class="graf graf--h3 graf-after--p">
                eWASM interpreters could be a sensible first change even though
                gas cost might not be practical in the beginning
              </h3>
              <p name="508c" id="508c" class="graf graf--p graf-after--h3">
                To appear in the part 3 or later
              </p>
              <h3 name="4404" id="4404" class="graf graf--h3 graf-after--p">
                Chain pruning will become more relevant as we start constraining
                the state growth
              </h3>
              <p name="3cc6" id="3cc6" class="graf graf--p graf-after--h3">
                To appear in the part 3 or later
              </p>
              <h3 name="da8a" id="da8a" class="graf graf--h3 graf-after--p">
                Ethereum protocol changes do not need to take a year to
                be prepared
              </h3>
              <p
                name="f15d"
                id="f15d"
                class="graf graf--p graf-after--h3 graf--trailing"
              >
                To appear in the part 3 or later
              </p>
            </div>
          </div>
        </section>
      </section>
      <footer>
        <p>
          By
          <a href="https://medium.com/@akhounov" class="p-author h-card"
            >Alexey Akhunov</a
          >
          on
          <a href="https://medium.com/p/d3d8fdcede10"
            ><time class="dt-published" datetime="2019-02-05T10:41:57.186Z"
              >February 5, 2019</time
            ></a
          >.
        </p>
        <p>
          <a
            href="https://medium.com/@akhounov/looking-back-at-the-ethereum-1x-workshop-26-28-01-2019-part-2-d3d8fdcede10"
            class="p-canonical"
            >Canonical link</a
          >
        </p>
        <p>
          Exported from <a href="https://medium.com">Medium</a> on July 28,
          2020.
        </p>
      </footer>
    </article>
  </body>
</html>
